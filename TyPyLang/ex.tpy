
# 1. Type Aliases-----------------
type MyInt = int
type NameAlias = str
print("Type Aliases:", MyInt, NameAlias)

# ----------------
a: MyInt = 10
b: NameAlias = "Alice"
print("Alias values:", a, b)

print("\n\n\n\n")

# 2. Optional Fields------------
age?: int
nickname?: str
score?: float

print("ПЕРЕД:", age, nickname, score)

age = 30
nickname = "Nick"
score = 99.5
print("ПОСЛЕ:", age, nickname, score)

print("\n\n\n\n")

# 3. Readonly Variables----------------------
readonly constVal: int = 100
readonly greeting: str = "Hello"
readonly pi: float = 3.14

print("только чтения:", constVal, greeting, pi)
try:
    constVal = 200
except TypeError as e3:
    print("Readonly eror caught:", e3)
try:
    greeting = "Hi"
except TypeError as e1:
    print("Readonly error caught:", e1)
try:
    pi = 3.1415
except TypeError as e2:
    print("Readonly error caught:", e2)
print("\n\n\n\n")


# 4. Type Assertions (as)-------------
x = 5 as int
y = 2.71 as float
flag = True as bool

print("Assertions correct:", x, y, flag)
try:
    bad = "abc" as int
except TypeError as e:
    print("Assertion error caught:", e)
try:
    bad2 = 123 as str
except TypeError as e:
    print("Assertion error cauht:", e)

print("\n\n\n\n")

# 5. Generics---------------------------------
def identity<T>(v: T) -> T:
    return v

def first<A, B>(a: A, b: B) -> A:
    return a

def pair<A, B>(a: A, b: B) -> list:
    return [a, b]

print("Generics identityFunc:", identity(123), identity("abc"), identity(3.14))
print("Generics 1:", first(1, "one"), first("first", 2))
print("Generics dec:", pair(1,2), pair("x","y"), pair(1,"one"))

print("\n\n\n\n")

# 6. Enums---------------
enum Color:
    RED
    GREEN = 5
    BLUE

enum Status:
    OFF
    ON
    UNKNOWN = 99

enum Size:
    SMALL, MEDIUM, LARGE

print("Enum Color:", Color.RED, Color.GREEN, Color.BLUE)
print("Enum Status:", Status.OFF, Status.ON, Status.UNKNOWN)
print("Enum Size:", Size.SMALL, Size.MEDIUM, Size.LARGE)

print("\n\n\n\n")

# 7. Interfaces & Implements ------------------
interface IPoint:
    x: int
    y: int
    def move(self, dx: int, dy: int): pass

interface IColorful extends IPoint:
    color: Color

class Point:
    def __init__(self, x: int, y: int):
        self.x = x
        self.y = y

    def move(self, dx: int, dy: int):
        self.x += dx
        self.y += dy

    def display(self):
        print("Point at", self.x, self.y)

class ColorPoint(Point):
    def __init__(self, x: int, y: int, color: Color):
        super().__init__(x, y)
        self.color = color

    def move(self, dx: int, dy: int):
        super().move(dx, dy)

    def display(self):
        print("ColorPoint at", self.x, self.y, "color:", self.color)

print("\n\n\n\n")

# 8. Access Control
class Secret:
    public info: str = "public"
    protected hint: str = "hint"
    private secret: str = "top-secret"

    def reveal(self):
        print("Info:", self.info)
        print("Hint:", self._hint)
        print("Secret:", self.__secret)

print("=== Classes & Interfaces ===")
p = Point(1, 2)
p.display()
cp = ColorPoint(5, 6, Color.BLUE)
cp.display()

s = Secret()
s.reveal()
try:
    s.info = "new"          # allowed
    print("Info changed to", s.info)
    s._hint = "no hint"     # should raise
except AttributeError as e:
    print("Protected error caught:", e)
try:
    s.__secret = "leaked"   # should raise
except AttributeError as e:
    print("Private error caught:", e)

print("\n\n\n\n")

# ===================================================
# 9. Type-checked Decorator
# ===================================================
def add(a: int, b: int) -> int:
    return a + b

print("add(2,3) =", add(2, 3))
try:
    add("2", "3")
except TypeError as e:
    print("type_checked error caught:", e)

print("\n\n\n\n")

# 10. Ensuring print('x as y:') is not read like function
print("This is not an assignment: x as y:", y)

print("\n\n\n\n")

# Main
def main():
    print("All tests executed.")

if __name__ == "__main__":
    main()
